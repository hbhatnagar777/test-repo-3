# -*- coding: utf-8 -*-

# --------------------------------------------------------------------------
# Copyright Commvault Systems, Inc.
# See LICENSE.txt in the project root for
# license information.
# --------------------------------------------------------------------------

""" Main file for helping testcases validate DR functionalities for Failovers
FailoverPeriodic
    Methods:
        validate_sync_status():     Validates the sync status and returns True/False
        validate_failover_status(): Validates the failover status and returns True/False
        validate_power_state():     Validates whether the power state of the VMs is correct
        validate_snapshot():        Validates that the failover snapshot exists with correct information
"""
from DROrchestration.Core._dr_validation import _DROrchestrationValidation
from VirtualServer.VSAUtils.VMHelpers.VmwareVM import VmwareVM
from VirtualServer.VSAUtils.VMHelpers.HyperVVM import HyperVVM

class FailoverPeriodic(_DROrchestrationValidation):
    """ This class is used to provide utility functions for validating failovers """

    def pre_validate_sync_status(self):
        """ Validates the sync status of the live sync pair before the failover operation """
        self.refresh()
        if self._live_sync_pair.status not in ['IN_SYNC', 'NEEDS_SYNC']:
            raise Exception(f"{self._live_sync_pair} is not in 'In sync' or 'Sync pending' status")
        self.log.info('Sync status for VM pair %s verified before failover', str(self._live_sync_pair))

    def validate_sync_status(self):
        """ Validates the sync status of the live sync pair """
        self.refresh()
        if self._live_sync_pair.status != 'SYNC_DISABLED':
            raise Exception(f"{self._live_sync_pair} is not in 'Sync disabled' status")
        self.log.info('Sync status for VM pair %s verified after failover', str(self._live_sync_pair))

    def validate_failover_status(self):
        """ Validates the failover status of the live sync pair is Failover complete """
        self.refresh()
        if self._live_sync_pair.failover_status != 'FAILOVER_COMPLETE':
            raise Exception(f"{self._live_sync_pair} does not have 'Failover complete' failover status")
        self.log.info('Failover status for VM pair %s verified after failover', str(self._live_sync_pair))

    def validate_power_state(self):
        """ Validates the power state of the source and destination VM """
        self.refresh_vm(source=True, basic_only=True)
        if self.source_vm.vm.is_powered_on():
            raise Exception(f"Source VM [{self._source_vm.vm_name}] is powered on even after failover")
        if not self.is_dvdf_enabled:
            self.refresh_vm(source=False, basic_only=True)
            if not self.destination_vm.vm.is_powered_on():
                raise Exception(f"Destination VM [{self._destination_vm.vm_name}] is powered off even after failover")
        self.log.info('Power states for VM pair %s verified after failover', str(self._live_sync_pair))

    def validate_snapshot(self, **kwargs):
        """ Validates that the snapshot generated by failover is correct """
        # Create DRVM validation object and then verify the snapshot of DRVM is correct with the correct job ID
        integrity_check = (
                (self._job_type == 'planned failover') and
                (
                        (isinstance(self._source_vm, VmwareVM) and isinstance(self._destination_vm, VmwareVM)) or
                        (isinstance(self._source_vm, HyperVVM) and isinstance(self._destination_vm, VmwareVM))
                )
        )
        self.source_vm.validate_snapshot(integrity_check=integrity_check, **kwargs)

        self.destination_vm.validate_snapshot_failover(**kwargs)
        self.log.info('Failover snapshot for VM pair %s verified after failover', str(self._live_sync_pair))

    def validate_dvdf(self, **kwargs):
        """ Validates that the DVDF settings are honoured on the hypervisor """
        self.destination_vm.validate_dvdf_on_failover(**kwargs)
        self.log.info('DVDF entities for VM pair %s verified after failover', str(self._live_sync_pair))


class FailoverContinuous(_DROrchestrationValidation):
    def validate_snapshot(self):
        """ Validates that the snapshot generated by failover is correct """

        self.refresh()
        if self.destination_vm.vm.VMSnapshot != 'BlrFailoverSnap':
            raise Exception(f"{self._live_sync_pair} is not having BlrFailoverSnap on DR VM after failover")
        else:
            self.log.info('Sucessfully validated BlrFailoverSnap is present on DR VM for pair %s after failover',
                          str(self._live_sync_pair))

    def pre_validate_sync_status(self):
        """ Validates the sync status of the continuous pair before the failover operation """

        self.refresh()
        if self._live_sync_pair.pair_status.name != 'REPLICATING':
            raise Exception(f"Failed failover pre validation as pair {self._live_sync_pair} is not Replicating")
        else:
            self.log.info('Sucessfully validated pair %s is Replicating before failover operation',
                          str(self._live_sync_pair))

    def validate_sync_status(self):
        """ Validates the sync status of the continuous pair """

        self.refresh()
        if self._live_sync_pair.pair_status.name != 'FAILOVER_DONE':
            raise Exception(f"Failed Sync status validation as pair {self._live_sync_pair} is not having status as "
                            f"'Failover Done'")
        else:
            self.log.info('Sucessfully validated pair %s is in Failover Done state', str(self._live_sync_pair))

    def validate_failover_status(self):
        """ Validates the failover status of the live sync pair is Failover complete """
        pass

    def validate_power_state(self):
        """ Validates the power state of the source and destination VM """

        if self.source_vm.vm.is_powered_on():
            raise Exception(f"Source VM [{self._source_vm.vm_name}] is powered on even after failover")
        if not self.destination_vm.vm.is_powered_on():
            raise Exception(f"Destination VM [{self._destination_vm.vm_name}] is powered off even after failover")
        else:
            self.log.info('Sucessfully validated power state of the VM: %s', str(self._live_sync_pair))

