import requests
import AutomationUtils.constants as AC

class AIAssistantValidator:

    def __init__(self, validation_data, log, config):
            """
            Initialize the AIAssistantValidator class.

            Args:
                validation_data (dict): The validation data.
                log: The log object.
                config: The configuration object.

            Attributes:
                validation_data (dict): The validation data.
                log: The log object.
                API_URL (str): The URL for the API endpoint.
                API_KEY (str): The authentication key for the API.
            """
            self.validation_data = validation_data
            self.log = log
            self.API_URL = config["apiEngineerEndPoint"] + "/ask"
            self.API_KEY = config["apiEngineerAuthKey"]

    def validate_main_step(self, validation_step, assistant_responses):
        """
        Validates the main step against the assistant responses.

        Args:
            validation_step (dict): The validation step containing the main step.
            assistant_responses (list): List of assistant responses.

        Returns:
            str: "Passed" if the main step is found in the assistant responses, "Failed" otherwise.
        """
        main_step = validation_step['answer'][-1]
        for step in assistant_responses:
            if main_step.lower() == step['endpoint'].lower():
                self.log.info("\tAt least we found one step which is important " + str(main_step))
                return "Passed"
        return "Failed"

    def validate_alternate_steps(self, validation_step, assistant_responses):
        """
        Validates the alternate steps of a validation step.

        Args:
            validation_step (dict): The validation step to be validated.
            assistant_responses (list): The list of assistant responses.

        Returns:
            str: The result of the validation. Possible values are "Passed" or "Failed".
        """
        if not validation_step.get('alternate'):
            return "Failed"
        alternate_steps = [step.lower() for step in validation_step.get('alternate')]
        if any(step['endpoint'].lower() in alternate_steps for step in assistant_responses):
            return "Passed"
        return "Failed"

    def verify_responses(self, validation_answer, assistant_responses):
        """
        Verifies the responses of the assistant against the validation answer.

        Args:
            validation_answer (str): The expected validation answer.
            assistant_responses (list): The responses generated by the assistant.

        Returns:
            str: The result of the verification. Returns "Passed" if the responses match the validation answer,
                 otherwise returns "Failed".
        """
        check_main_step = self.validate_main_step(validation_answer, assistant_responses)
        check_alternate_step = self.validate_alternate_steps(validation_answer, assistant_responses)
        if check_main_step == "Passed" or check_alternate_step == "Passed":
            return "Passed"
        else:
            return "Failed"

    def validate_ai_assistant(self):
        """
        Validates the AI assistant by sending questions to the API and comparing the responses.

        Returns:
            results (list): A list of dictionaries containing the question, expected answer, assistant response, result, and time taken for each validation.
        """
        results = []
        for question,value in self.validation_data.items():
            self.log.info("")
            self.log.info(f"{question}\tQuestion is "+ str(value["question"]))
            headers = {"Content-Type": "application/json"}
            if self.API_KEY:
                headers["x-api-key"] = f"{self.API_KEY}"
            body = {
                "query": value["question"],
                "servicePack": "tip",
                "userHash": "NA",
                "ccHash": "NA",
                "ignoreCache": True
            }
            response = requests.post(self.API_URL, headers=headers, json=body)
            self.log.info("\n", response.status_code)
            assistant_responses = []
            if response.status_code == 200:
                validation_answer = value["answer"]
                assistant_responses = response.json()["answer"]
                self.log.info("\tTime taken is "+ str(response.elapsed.total_seconds()))
                if len(validation_answer) != len(assistant_responses):
                    self.log.info("\tNumber of steps are not matching")
                    self.log.info("\tValidation answer is " + str(validation_answer))
                    self.log.info("\tAssistant response is ")
                    for response_steps in assistant_responses:
                        self.log.info("\t\t !!" +  str(response_steps['endpoint']))
                    if value.get("alternate"): self.log.info("\tAlternate answer is "+str(value["alternate"]))
                    result = self.verify_responses(value, assistant_responses)
                else:
                    for i in range(len(validation_answer)):
                        self.log.info(f"\tValidation answer with step {str(i)} is " + validation_answer[i].lower())
                        self.log.info(f"\tAssistant response with step {str(i)} is "+ str(assistant_responses[i]['endpoint'].lower()))
                        if validation_answer[i].lower() != assistant_responses[i]['endpoint'].lower():
                            result = self.verify_responses(value, assistant_responses)
                            break
                    else:
                        result = "Passed"
            else:
                result = f"API Error: {response.status_code}"

            results.append({"Question": question, "Expected Answer": value["answer"] , "Assistant Response": assistant_responses, "Result": result, "TimeTaken": response.elapsed.total_seconds()})

        return results

# Load validation data from JSON file
# with open(os.path.join(os.path.dirname(__file__),"validation.json"), "r") as f:
#     validation_data = json.load(f)

# log.basicConfig(level=self.log.info, format='%(asctime)s - %(levelname)s - %(message)s', filename=os.path.join(AC.LOG_DIR,'validation.log'))

# validator = AIAssistantValidator(validation_data)
# validation_results = validator.validate_ai_assistant()

# for result in validation_results:
#     self.log.info(f"{result['Question']}: {result['Result']}")

# passed_results = sum(result['Result'] == 'Passed' for result in validation_results)
# failed_results = sum(result['Result'] == 'Failed' for result in validation_results)

# self.log.info(f"Total cases passed: {passed_results}")
# self.log.info(f"Total cases failed: {failed_results}")

# if all(result["Result"] == "Passed" for result in validation_results):
#     self.log.info("Overall Validation: Passed")
# else:
#     self.log.info("Overall Validation: Failed (See individual test results for details)")
#     for results in validation_results:
#         if results['Result'] == "Failed":
#             self.log.info("Query Number ", str(results['Question']), validation_data[str(results['Question'])]['question'])